# Finalformat.
#### Video demo: <https://youtu.be/E-hZDpOHDJI>
#### Description:
In project.py, I developed an algorithm to transform .docx and .html files into PDFs formatted in the style of fiction books. I designed the layout using Figma and utilized Google Fonts, along with the Mammoth and FPDF libraries. This project can be useful for creating prototypes or initial versions of fiction and non-fiction projects, as long as they are formatted using the Title followed by a Body of paragraphs paradigm.

In HTML, it would look something like:

```
<h1>Chapter 01</h1>
<p>Text</p>
<p>More Text</p>
â€¦
```

A similar structure can be used with the formatting of docx files in software like Google Docs or Microsoft Word. The Mammoth library handles the translation of Title and Paragraph formatting from the docx file to HTML tags.

## Project.py
Let's take a look at the algorithm itself. You can convert a file by running the following code in the Terminal:

```
python project.py file.docx
```
This would be the simplest version of the command-line argument, but there are more possibilities. Some optional arguments are handled through argparse, customizing formatting options. Let's take a look at the --help generated by the program:
```
This program transforms docx and html files into formatted pdfs

positional arguments:
  path                  path to the docx or html file you want to format into pdf

options:
  -h, --help            show this help message and exit
  -s SIZE, --size SIZE  size of the page: expected Regular or Small. If omitted, defaults to Regular
  -f FONT_BODY, --font_body FONT_BODY
                        Pick one of the available fonts. 0: PT Serif; 1: EB Garamond; 2: Fira Sans. Defaults to 0 if omitted.
  -t FONT_TITLE, --font_title FONT_TITLE
                        0: Playfair Display; 1: DM Sans; 2: Raleway; 3: Playfair Display SC. Defaults to 0 if omitted.
  -ta TITLE_ALIGN, --title_align TITLE_ALIGN
                        write L for Left, R for Right, C for Center alignment of the title. Defaults to Left

Remember to input a docx or html file with a Title followed by Paragraphs sctructure!
```
You can include -s Small to format the PDF in a smaller size; include -f 2, -t 1 to change fonts to Fira Sans and DM Sans; choose right alignment by typing -ta R. All these parameters will make a difference in the creation of the final PDF file.

This would look like:

```
python project.py file.docx -s Small -f 2 -t 1 -ta R
```

Speaking of formatting, three classes were created at the top of project.py. The Book class stores important information about the book, including the list (index) of chapters; the Chapter class stores the basic chapter structure, title, and body of text; and the PDF class, which is a subclass of FPDF. This design choice was necessary to override some features of FPDF in order to customize the footer of the pages and the position of the numbers on them, for example. Notice that, considering a possible future print, the numbers are placed on the left or right, depending on whether they are even or odd.

Another advantage of using Classes and Objects is the inclusion of related methods. For example, book.change_chapters(n1, n2) is a method to swap the position of two chapters in book.index.

Moving on to the main() function, after parsing the command-line arguments, we call read_file(args.path), which will read the HTML or docx file and return a list of Chapter objects. This list will later be passed to an instance of the Book class.

Next, we call get_meta(), prompting the user to enter some extra information to be integrated into the formatting, such as title, author, etc., returning a dictionary.

With the data from the command-line arguments and the metadata, we can now instantiate Book. Then, we ask if the user wants to change the order of some chapters, and if so, we ask the user to input these chapters in pairs, separated by spaces. "2 3 1 4 5 2" is a valid input, which would swap chapter 2 with 3, 1 with 4, and 5 with 2. This swap occurs when calling the change_index function.

During the execution of the program, some helper functions come along the way. We have the assign_fonts method in PDF class, which can parse the numbers given as references in the command-line arguments to actual font names and paths in the folder. This is crucial because we are using custom fonts, that will be loaded by another function later on. We have also replace_tags, a function that helps parsing some extra HTML tags that could come along the way.

Aditionally, it's interesting to point out that the re module was quite usefull in the read_file, but also in other parts of the program, being really helpfull to use regex sintax to find and catch some patterns to identify were a Chapter begins and ends, for example.

Finally, all that's left is to create the PDF. The entire work is concentrated in the consolidate_pdf function. It's a questionable design choice since the function ended up being longer than main; nonetheless, it's a function that performs only one (lengthy) task, and it seemed more reasonable than creating a new function for each different section of the PDF.

consolidate_pdf defines margins and PDF parameters and then needs to call load_fonts, a function that find the fonts in the fonts folder, and then loads then to work with the fpdf library. After that, it's a matter of simply go on creating page by page of the PDF, iterating through the list of chapters, adding metadata, and formatting it as close as possible to the format of a commercial book.

In the end, project.py will create a new file with the same name as the path you gave in the command-line arguments, but with .pdf at the end. This means the output will always be saved in the same folder as the input file.

As aditional features to the future, I would like to improve some functions in the FPDF class to improve for example the indentation of the program. As another feature, it would be interesting to create the Cover of the book inside of the program. For the future, I plan making a web version of finalformat with graphical interface and some aditional features like those. But that is a talk for another time.

### This was finalformat. This was CS50P.
